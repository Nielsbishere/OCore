#include <lighting.glsl>

layout(binding = 0) uniform Global {

	Vec3 ambient;
	f32 time;

	Vec2u resolution;
	f32 power;
	u32 view;
	
} global;

layout(binding = 1) uniform Views_noalloc { ViewBuffer viewData; };

layout(binding = 2) uniform sampler samp;
layout(binding = 3) uniform texture2D tex[2];

layout(std430, binding = 4) readonly buffer DirectionalLights {

	Light light[];

} dir;

layout(std430, binding = 5) readonly buffer PointLights {

	Light light[];

} point;

layout(std430, binding = 6) readonly buffer SpotLights {

	Light light[];

} spot;

layout(std430, binding = 7) readonly buffer Materials {

	MaterialStruct mat[];

};

layout(binding = 8, rgba16f) uniform image2D outputTexture;
layout(binding = 9) uniform texture2D uvs;
layout(binding = 10) uniform sampler nearest;
layout(binding = 11) uniform utexture2D materials;
layout(binding = 12) uniform texture2D depth;
layout(binding = 13) uniform texture2D normals;

Vec4 sample2D(sampler s, TextureHandle handle, Vec2 uv){
	return texture(sampler2D(tex[handle], s), uv);
}

//Spheremap transform
Vec3 unpackNormal(Vec2 enc) {
    Vec2 fenc = enc * 4 - 2;
    f32 f = dot(fenc, fenc);
    f32 g = sqrt(1 - f / 4);
    return Vec3(fenc * g, 1 - f / 2);
}

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main() {

	Vec2u coords = gl_GlobalInvocationID.xy;

	if(coords.x >= global.resolution.x || coords.y >= global.resolution.y)		//TODO: Avoid this branching
		return;

	Vec2 globalUv = Vec2(coords) / Vec2(global.resolution - 1);

	View view = viewData.views[global.view];
	Camera cam = viewData.cameras[view.camera];

	Vec2 uv = texture(sampler2D(uvs, nearest), globalUv).xy;
	Vec2 sNormal = texture(sampler2D(normals, nearest), globalUv).xy;
	u32 sMaterial = texture(usampler2D(materials, nearest), globalUv).r;
	f32 sDepth = texture(sampler2D(depth, nearest), globalUv).r;

	Vec3 pos = reconstructPosition(globalUv, sDepth, view.vpInv);
	Vec3 normal = unpackNormal(sNormal);
	u32 material = max(1, sMaterial) - 1;

    //Get camera position
	Vec3 cpos = normalize(cam.position - pos);

    //Calculate lighting result
	LightResult lr = { Vec3(0, 0, 0), 0, Vec3(0, 0, 0), 0 };
	
	for(int i = 0; i < dir.light.length(); i++){
		LightResult res = calculateDirectional(dir.light[i], pos, normal, cpos, global.power);
		lr.diffuse += res.diffuse;
		lr.specular += res.specular;
	}
	
	for(int j = 0; j < point.light.length(); j++){
		LightResult res = calculatePoint(point.light[j], pos, normal, cpos, global.power);
		lr.diffuse += res.diffuse;
		lr.specular += res.specular;
	}
	
	for(int k = 0; k < spot.light.length(); k++){
		LightResult res = calculateSpot(spot.light[k], pos, normal, cpos, global.power);
		lr.diffuse += res.diffuse;
		lr.specular += res.specular;
	}
	
    //Get material
	MaterialStruct m = mat[material];
    
    //Get diffuse texture
	Vec3 dif = sample2D(samp, m.t_diffuse, uv).rgb;
    
    //Write lighting result to render target
    imageStore(outputTexture, Vec2i(coords), Vec4(calculateLighting(lr, dif, global.ambient, m), 1));

}