# Osomi Graphics Core (ogc)

## Graphics class

The Graphics instance is stored in GraphicsInterface, when it is destroyed, all graphics objects are released. 

### Graphics.finish

Before you start destroying resources, you need to ask for the Graphics to finish the previous frame(s). This can be done by calling g.finish. So a destructor would look like the following:

```cpp
g.finish();
g.destroy(tex);
```

### GraphicsExt

In ogc there's a lot of extended structs. These structs are used to store API-dependent data. For setting up the graphics API, a lot of extra data is needed. This data is stored in GraphicsExt (which is a typedef for an underlying struct). An example is VkGraphics, which stores all info required for a Vulkan instance & swapchain. Be careful when using GraphicsExt and use ifdefs if you need API-dependent data.

```cpp
//Correct
#ifdef __VULKAN__
VkGraphics &gext = g.getExtension();
	//Access Vulkan information
#endif

//Correct
GraphicsExt &gext = g.getExtension();

//Incorrect
VkGraphics &gext = g.getExtension();

//Incorrect
GraphicsExt &gext = g.getExtension();
	//Access Vulkan information

```

When accessing Vulkan data through either GraphicsExt or VkGraphics, you have to wrap it into an `#ifdef __VULKAN__`. However, if you just pass GraphicsExt around and you don't use any of the fields, you don't have to.

### Helper functions

There are a few helper functions for TextureFormat in Graphics. TextureFormat is the standard layout of a Texture or shader variable/vbo variable. 

```cpp
bool df = Graphics::isDepthFormat(myTextureFormat);		//Check if depth format
u32 csiz = Graphics::getChannelSize(myTextureFormat);	//Get bytes per channel
u32 cs = Graphics::getChannels(myTextureFormat);		//Get channels for format
u32 siz = Graphics::getFormatSize(myTextureFormat);		//cs * csiz

TextureFormatStorage stor = 							//What the format represents
    Graphics::getFormatStorage(myTextureFormat);		//Low lvl (int, float, etc.)

bool compat = Graphics::								//If two formats are equal
	isCompatible(myTextureFormat, TextureFormat::RGBA8)	//except channel size
    
Vec4d col = Graphics::
	convertColor(myCol, myTextureFormat);				//Sets col[cs til 4] to 0
```

## GraphicsObject

A GraphicsObject is created as following:

```cpp
T *t = g.create("My graphics object", TInfo(params));
```

So for a texture, it would be:

```cpp
Texture *tex = g.create("My texture", TextureInfo("res/textures/my_texture.png"));
```

Whenever you create a GraphicsObject, don't forget to call destroy at the end. This *doesn't* release the resource, until it reaches *zero references*. "g.use" increments the refCount to an object, allowing you use the same resource multiple times. Every g.use requires a g.destroy and at least 1 destroy is needed (when allocating a GO). Whenever an object is allocated, the TInfo struct becomes inaccessible and can only be modified through the GraphicsObject directly.

```cpp
//initScene
g.use(tex);			//Start using the texture

//Destructor
g.destroy(tex);		//Stop using the texture
```

This way of maintaining references allows you to preserve a ShaderBuffer that was automatically created for example (and then passing it to a different shader). 

```cpp
g.printObjects();	//Print all graphics objects (for debugging)
g.contains(tex);	//If texture is still present
g.get<Texture>();	//Get all allocated Textures (std::vector<Texture*>)
```

### Ownership

A GraphicsObject can be owned by the API or driver, which means that there is no allocated data maintained by us. This still means you have to call destroy on them, but the driver will take care of the data. An example is a VersionedTexture, Texture and RenderTarget; the backbuffer is owned by the driver and won't be deleted by us. It isn't implemented for other types yet.

### Shader

A shader is code specialized to run on the GPU; this can be compute shaders (calculating things in parallel on the GPU), graphics shaders (~~mesh,~~ vertex, geometry, fragment) or ~~raytracing shaders (raygen, miss, closest hit, any hit, intesection)~~. The ocore abstraction layer allows automatic shader introspection, allowing for the program to inspect all variables used in the shaders. This uses the oiSH format; generated by the oiSH compiler.

#### ShaderInfo

```cpp
String path		//owc-formatted path to the oiSH file
```

### Mesh

A mesh is defined as an allocation into a MeshBuffer. This MeshBuffer has a layout, that specifies how the vertex data is structured. This data can be maintained manually, or can be automatically set up by the MeshManager. This data is stored in oiRM format to support all functionality; like sized variables.

#### MeshInfo

```cpp
MeshBuffer *parent,			//Maintains all meshes
u32 vertices,				//Number of vertices
u32 indices,				//Number of indices
std::vector<Buffer> vbo;	//VBOs (have to conform to MeshBuffer's layout)
Buffer ibo;					//IBO (u32[])
```

#### MeshAllocationInfo

```cpp
String path,						//owc-formatted path to the oiRM file
MeshBuffer *parent,					//If null tries to find or allocate MeshBuffer
MeshAllocationHint hintVertices,	//How the vertices/mesh buffer is allocated
MeshAllocationHint hintIndices		//^ indices; read MeshManager for more info
```

### MeshBuffer

A MeshBuffer is the index buffer and/or vertex buffers that are required to render a model. The requirements of a Mesh are given by the `oiRM::convert` function, as a MeshBufferInfo. This struct can then be modified to allow for multiple mesh allocations. You can also manually create these, like any other GraphicsObject.

#### MeshBufferInfo

```cpp
u32 maxVertices,		//How many vertices are allowed in this MeshBuffer
u32 maxIndices,			//^ indices
std::vector<
    std::vector<
    	std::pair<
    		String, TextureFormat
    	>
    >
> layout,				//The layout of the vertex buffers and names of attributes
TopologyMode topology,	//The topology that is used for this MeshBuffer
FillMode fillMode		//^ fillMode
```

### MeshManager

A MeshManager is responsible for maintaining meshes and mesh buffers (in a more user friendly way). This automatically allocates buffers when you need them. It uses the MeshAllocationHint to determine that; as well as existing buffers.

#### MeshManagerInfo

```cpp
u32 maxVertices,			//The default max vertices for MeshBuffers
u32 maxIndices,				//^ indices
TopologyMode toplogyMode,	//What TopologyMode to use when it isn't specified
FillMode fillMode			//^ FillMode
```

### PipelineState

A PipelineState is the required settings for a graphics pipeline; for other pipelines this is unused.

#### PipelineStateInfo

```cpp
DepthMode depth,		//The depth mode that is used (mask and test)
BlendMode blend,		//What type of blending to use
CullMode cull,			//Use backside, frontside or no culling
WindMode wind,			//CCW or CW
f32 lineWidth,			//Hint for lineWidth (in pixels)
u32 samples				//How many samples to use (MSAA)
```

### RenderTarget

The term 'render target' refers to the result of rendering. An example is the default back buffer; which can be obtained through Graphics.getBackBuffer. This class automatically takes care of versioning (double buffering, triple buffering, etc.). You can send this to a shader by getting one of the outputs (depth buffer or color outputs). 

```cpp
VersionedTexture *col0 = g.getBackBuffer()->getTarget(0);
Texture *depth = g.getBackbuffer()->getDepth();
```

If you disable depth, the depth texture will be nullptr. You can get the number of targets (color outputs) by using the getTargets function.

##### RenderTargetInfo

```cpp
Vec2u res, 							//The resolution of the render target
TextureFormat depth, 				//Typically Depth, Undefined for disabled
std::vector<TextureFormat> formats	//List of texture formats for the output
```

### Pipeline

A Pipeline is the required GraphicsObject for a shader to run and setup all important data in the background. The pipeline info depends on the shader type; graphics shaders require more info than a compute shader.

#### PipelineState (compute)

```cpp
Shader *shader					//Compute shader
```

#### PipelineState (graphics)

```cpp
Shader *shader,					//Graphics shader
PipelineState *state,			//Rasterizer info, blend info, etc.
RenderTarget *target,			//Where to render to
MeshBuffer *meshes				//Which layout to use
```

### Texture

A Texture is an array of attributes. This can be loaded from a file, written to from render target, written to from compute shader or filled in on the CPU.

#### TextureInfo (disk)

```cpp
String path,					//Load from file
TextureFormat format			//What type of format to load (s)R(G)(B)8
```

#### TextureInfo (empty)

```cpp
Vec2u res,						//Resolution of texture
TextureFormat format,			//Any texture format
TextureUsage usage				//Use of texture (render target/depth or image)
```

### Sampler

A sampler is the information required to get a sample from a texture.

#### SamplerInfo

```cpp
SamplerMin minification,		//Minification filter; when result is smaller
SamplerMag magnification,		//Magnification filter; when result is bigger
SamplerWrapping s,				//Wrapping on the s-axis (srt; aka uvw)
SamplerWrapping r,				//^ r-axis
SamplerWrapping t,				//^ t-axis
u32 aniso						//Max anisotropic filter; hardware dependent
```

### DrawList

A DrawList is like a multi draw indirect call; it automatically batches meshes together as one call to the GPU. This requires the Mesh to be in the same MeshBuffer as specified in the DrawList.

#### DrawListInfo

```cpp
MeshBuffer *meshBuffer,			//The MeshBuffer this DrawList uses
u32 maxBatches,					//How many separate mesh draw commands it can fit
bool clearOnUse					//If you want to re-use the DL, set this to false
```

### CommandList

A CommandList contains all commands to send to the GPU.

#### CommandListInfo

The command list doesn't require any additional arguments.

### TextureList

Is the object created to store multiple textures; so a TextureHandle (uint) can used to identify a Texture. TextureList doesn't currently support VersionedTextures.

#### TextureListInfo

```cpp
u32 count						//How many textures it can hold
```

### MaterialList

MaterialList has all materials; this is needed for the way draw calls are structured. This means that a MaterialHandle (uint) can be used to identify a Material.

#### MaterialListInfo

```cpp
TextureList *textures,		//The textures that are used for these materials
u32 maxCount				//How many materials can be used
```

### VersionedTexture

### Camera

A camera is defined as an object in space; as simple as having a current eye and a center or direction, as well as a normal (pointing up). Unlike most camera implementations, the clipping planes, aspect ratio, resolution and FOV aren't implemented into the camera. This is because you might have multiple frusta for one camera (aka; different views). For resource reuse, we decided to create a separate object "CameraFrustum", which has the projection matrix, while the camera has the view matrix. These two objects are combined into a View in order to create the VP matrix.

#### CameraInfo

```cpp
ViewBuffer *parent,		//The object that stores the cameras, frusta and views
Vec3 position,			//The location of the camera
Vec4 directionOrCenter,	//When w=0; forward direction, w=1; focus point
Vec3 up					//The camera's up direction (normal)
```

#### CameraStruct (GPU)

```cpp
struct CameraStruct {	//112 bytes (7 'lines'; 7 * 16)
    
    Matrix v;			//View matrix

    Vec3 position;		//Camera 'eye'
    f32 p0;				//Padding (0)

    Vec3 up;			//Normal / camera up direction
    f32 p1;				//Padding (0)

    Vec4 forward;		//Either forward direction or center
    
};
```

### CameraFrustum

A frustum is the projection matrix. This object has to be updated when the aspect ratio and/or resolution changes.

##### CameraFrustumInfo

```cpp
ViewBuffer *parent,		//The object that stores the cameras, frusta and views
Vec2u res,				//The resolution
f32 aspect,				//The aspect ratio (not always res.x / res.y)
f32 fov,				//The field of view
f32 near,				//Near plane (depth = 0)
f32 far					//Far plane (depth = 1)
```

##### CameraFrustumStruct (GPU)

```cpp
struct CameraFrustumStruct {	//96 bytes (6 lines)
    
    Matrix p;					//Projection matrix

    f32 near;					//Near clipping plane (depth = 0)
    f32 far;					//Far clipping plane (depth = 1)
    f32 aspect;					//Aspect ratio (resolution.x / resolution.y)
    f32 fov;					//FOV in degrees

    Vec2u resolution;			//Resolution (w, h) in pixels
    u32 p0;						//Padding (0)
    u32 p1;						//Padding (0)
    
};
```

### View

A view is the view projection matrix; it is a combination of a Camera and a CameraFrustum. This object is automatically updated when one of the referenced objects changes. Keep in mind that if it is updated, you have to change all pre-baked MVPs.

#### ViewInfo

```cpp
ViewBuffer *parent,				//Stores the cameras, frusta and views
Camera *camera,					//The transformation of the View
CameraFrustum *frustum			//The projection of the View
```

#### ViewStruct (GPU)

```cpp
struct ViewStruct {				//80 bytes (5 lines)

    CameraHandle camera,		//Index of camera in parent
    ViewFrustumHandle frustum,	//Index of frustum in parent
    u32 p0,						//Padding (0)
    u32 p1,						//Padding (0)

    Matrix vp;					//ViewProjection matrix (vp * m = mvp)
    
};
```

### ViewBuffer

The view buffer is the object responsible for managing all views, cameras and frusta. When one is updated, it updates the matrix and sends the data to the GPU.

#### ViewBufferInfo

Empty constructor; it automatically stores 128 cameras, frusta and 256 views. These should be allocated after the ViewBuffer has been allocated.

#### ViewBufferStruct (GPU)

```cpp
//128 * (7 + 6) + 256 * 5 = 128 * 23 lines = 2 944 lines = 46 KiB
struct ViewBufferStruct {
  
    CameraStruct cameras[128];			//All cameras
    CameraFrustumStruct frusta[128];	//All frusta
    View views[256];					//All views
    
};
```

### ShaderStage

### ShaderBuffer

### GBuffer

## (Basic) Graphics interface

ogc hooks into owc, it requires information about the current Window for setting up a swapchain and all information about the backbuffer. All of these get passed through a WindowInterface, which is what GraphicsInterface builds on. GraphicsInterface provides you with a few extra function that allow you to manage events yourself. 

```cpp
void initScene() override;			//Called when the scene should be initialized
									//(graphics is intialized and swapchain is ready)

void initSceneSurface(Vec2u res) override;	//Called when the frame has been updated (resize)

void renderScene() override;		//Called to render the scene
```

### Resizing

When you resize your screen, a lot of data becomes invalid. The back buffer suddenly changes resolution (or aspect) and all render targets now have the wrong resolution. This means you have to destroy all pipelines and render targets that have the wrong resolution. Remember that if the render target is used in a shader, you also have to update the value in the shader.

```cpp

void MainInterface::initSceneSurface(Vec2u res){

	//Destroy old data

	if (pipeline != nullptr) {
		g.destroy(renderTarget);
		g.destroy(pipeline);
		g.destroy(pipeline0);
	}

	//Recreate render targets and pipelines
    
	renderTarget = g.create("Post processing target", RenderTargetInfo(res, TextureFormat::Depth, { TextureFormat::RGBA16f }));
	g.use(renderTarget);

	shader0->set("tex", renderTarget->getTarget(0));

	pipeline = g.create("Rendering pipeline", PipelineInfo(shader, pipelineState, renderTarget, meshBuffer, camera));
	g.use(pipeline);

	pipeline0 = g.create("Post process pipeline", PipelineInfo(shader0, pipelineState, g.getBackBuffer(), meshBuffer0, camera));
	g.use(pipeline0);

}
```

Above all the pipelines are recreated, because the render targets have been changed. The post processing target (the target we apply post processing to) gets used as the input for our post processing shader (shader0).
